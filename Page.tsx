/*
This file was generated by https://github.com/pmndrs/gltfjsx and then
customized manually. It uses drei's new useAnimations hook which extracts
all actions and sets up a THREE.AnimationMixer for it so that you don't have to.
All of the assets actions, action-names and clips are available in its output. 
*/

import React, {
  useEffect,
  useState,
  useMemo,
  useRef,
  Dispatch,
  SetStateAction,
} from "react";
import {
  useGLTF,
  useTexture,
  useCursor,
  useAnimations,
} from "@react-three/drei";
import { ObjectMap, useGraph } from "@react-three/fiber";
import { a, useSpring } from "@react-spring/three";
import { SkeletonUtils } from "three-stdlib";
import { LoopRepeat } from "three";
type GLTFResult = ObjectMap & {
  nodes: {
    Plane: THREE.Mesh;
    Plane_1: THREE.Mesh;
  };
};
export default function Page({
  scene,
  animations,
  material,
  materialWhite,
  index,
  setImagesReady,
  setStartAnimation,
  setUploaded,
  StartAnimation,
  ...props
}: {
  scene: THREE.Group<THREE.Object3DEventMap>;
  animations: any;
  material: any;
  materialWhite: any;
  index: any;
  StartAnimation?: Boolean;
  setUploaded?: Dispatch<SetStateAction<boolean | null>>;
  setImagesReady?: Dispatch<SetStateAction<boolean>>;
  setStartAnimation?: Dispatch<SetStateAction<boolean>>;
}) {
  // useGraph creates two flat object collections for nodes and materials
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes } = useGraph(clone) as GLTFResult;
  const group = useRef<THREE.Group>(null);

  const { actions, names } = useAnimations(animations, group);
  // Change animation when the index changes
  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    if (actions && names[0]) {
      // In the clean-up phase, fade it out
    }
  }, [actions, names]);

  useEffect(() => {
    let onFinshed: any = null;
    if (setImagesReady && setStartAnimation && setUploaded) {
      onFinshed = () => {
        console.log("Finished");
        setImagesReady(false);
        setStartAnimation(false);
        setUploaded(null);
        actions[names[0]]
          ?.getMixer()
          .removeEventListener("finished", onFinshed);
      };
    }

    if (StartAnimation || true) {
      if (onFinshed) {
        actions[names[0]]?.getMixer().addEventListener("finished", onFinshed);
      }
      actions[names[0]]?.setLoop(LoopRepeat, 10);
      actions[names[0]]
        ?.play()
        .reset()
        .startAt((3 / 24) * index);
    }
  }, [StartAnimation, actions]);
  return (
    <group ref={group} {...props} dispose={null}>
      <mesh
        name="Plane"
        position={[0, -0.000192 * index, 0]}
        geometry={nodes.Plane.geometry}
        material={material}
        morphTargetDictionary={nodes.Plane.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane.morphTargetInfluences}
      />
      <mesh
        name="Plane_1"
        position={[0, -0.000192 * index, 0]}
        geometry={nodes.Plane_1.geometry}
        material={materialWhite}
        morphTargetDictionary={nodes.Plane_1.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane_1.morphTargetInfluences}
      />
    </group>
  );
}
